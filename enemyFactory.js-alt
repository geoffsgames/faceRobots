//plain - just knives
var minEnemyBlocks = 5;
var maxEnemyBlocks = 15;
var minEnemyGrid = 6;
var maxEnemyGrid = 9;

var probMotorFullLength = 0.5;
var enemyKnifeProb = 0.2;

var heartInBiggestProb = 0.95;


designEnemy = function(initialLandscape, addSprings){
	var size = Math.seededRandom(minEnemyGrid, maxEnemyGrid);
	
	var numBlocks = Math.seededRandom(minEnemyBlocks, (size - 2)  * (size - 2) );
	
	var enemyGrid =[];
	for(var i =0; i < size; i+= 1){
		enemyGrid.push(new Array(size));
	};
	
	var blockArray = [];
	var options = [];

	//add blocks to the grid at random
	for(var i =0; i < numBlocks; i += 1){
		var newX = -1;
		var newY = -1;
		if(i == 0){//add the first block anywhere
			newX = Math.seededRandom(1,size - 2);
			newY = Math.seededRandom(1,size - 2);
			
		}//subsequent blocks are added so that they are next to existing block
		else{
			
			var wrongPlace = true;
			while(wrongPlace){
				var index = 0;
				
				//there is one "option" for every block already added. 
				//option is a 4 item array where [0] means new piece can be added to the left, 
				//[1] means can be added right, [2] means can be added top and [3] means can be added bottom
				if(options.length > 1) //if more than one block has been added choose to add adjacent to one of them at random, get the appropriate option[]
					index = Math.seededRandom(0, options.length - 1);
				var option = options[index];
				if(option == undefined)
					alert("something went wrong in landscape.designEnemy(line 175)");
				var oldBlock = blockArray[option[1]];
				
				newX = oldBlock.myX;
				newY = oldBlock.myY;
				if(option[0] == 0)
					newX -= 1;
				else if(option[0] == 1)
					newX += 1;
				else if(option[0] == 2)
					newY -= 1;
				else if(option[0] == 3)
					newY += 1;
				
				if(newX < 1 || newX >= size - 1 || newY < 1 || newY >= size - 1 || enemyGrid[newX][newY] != undefined){
					//I thought I could add to left/right/up/down of this block but turned out I can't or I already filled it
					
					options.splice(index, 1);//remove that option
					wrongPlace = true;
				}
				else{
					wrongPlace = false;
				}
			};
			
		}
		
		
		var block = new TempBlock("wall",newX,newY);
		enemyGrid[newX][newY] = block;
		blockArray.push(block);
				
		if(newX > 1)
			options.push([0,i]);
		if(newX < size - 2)
			options.push([1,i]);
		if(newY > 1)
			options.push([2,i]);
		if(newY < size - 2)
			options.push([3,i]);
	};
	
	
	//add either 1 knife or 2 to 4 knives (equal chance of either)
	var numKnives = 1;
	
	if(Math.seededRandom() == 0 && initialLandscape)
		numKnives = Math.seededRandom(2,4);


	var nKnives = 0;
	

	for(var pd = 1; pd < size / 2 && nKnives < numKnives; pd += 1){ //pd = perimeter depth - work round enemy in ever decreasing size perimeters
		var options = [];
		
		//add every possible point around the perimeter
		for(var al = pd; al < size - pd; al += 1){ //al = along length - how far down the length
			for(var ws = 0; ws < 4; ws += 1){ //ws = which side
				options.push([al,ws]);
			}
		}
		
		//e.g. if adding to right try adding to right of rightmost blocks at various different heights (options)
		//if can't find any rightmost block to add to right of then start moving inwards (increment pd)
		while(options.length > 0 && nKnives < numKnives){
			var ind = 0;
			if(options.length > 1)
				ind = Math.seededRandom(0, options.length - 1);
			var option = options[ind][0];
			var side = options[ind][1]
			options.splice(ind, 1);
			
			
			//1 = top, 2 = right, 3 = bottom, 4 = left
			var x, y;
			var nextoX, nextoY;
			
			if(side == 1){//start at top side, work downwards
				x = option;
				y = pd;
				nextoX = x;
				nextoY = y - 1;
			}
			else if(side == 2){//start at right side, work leftwards
				x = size - pd - 1;
				y = option;
				nextoX = x + 1;
				nextoY = y;					
			}
			else if(side == 3){
				y = size - pd - 1;
				x = option;
				nextoX = x;
				nextoY = y + 1;
			}
			else{
				x = pd;
				y = option;
				nextoX = x - 1;
				nextoY = y;					
			}
				

			if(enemyGrid[x][y] != undefined && enemyGrid[x][y].type == "wall"){
				if(enemyGrid[nextoX][nextoY] == undefined){
					enemyGrid[nextoX][nextoY] = new TempBlock("knife",nextoX,nextoY);
					if(addSprings){
						enemyGrid[x][y] = new TempBlock("spring",nextoX,nextoY);
						var springStrength = Math.seededRandom(1,numSpeeds)
					}
					nKnives += 1;
				}
			}
		}
	}

	
	var heartAdded = false;
	while(blockArray.length > 0 && !heartAdded){
		var index = Math.seededRandom(0, blockArray.length - 1);
		var x = blockArray[index].myX;
		var y = blockArray[index].myY;
		
		//can't put heart where knife or other weapon is so only put if it is wall
		if(blockArray[index].type == "wall"){
			//weighted = give higher probability that heart will be in centre
			//centrality should be almost 0 when at edge and 1 when at centre
			var centrality = Math.pow(Math.min((Math.min((size - x),x) / (size / 2)),(Math.min((size - y),y) / (size / 2))),4);
			
			if(Math.seededRandomDouble() < centrality){
				enemyGrid[x][y] = new TempBlock("heart",x,y);
				blockArray.splice(index,1);
				heartAdded = true;
			}
		}
		else
			blockArray.splice(index,1); //remove weapons from list of possible locations so don't try to overwrite weapon again
		
	}
	
	return enemyGrid;
}



function union(setA, setB) {
    let _union = new Set(setA)
    for (let elem of setB) {
        _union.add(elem)
    }
    return _union
}

designEnemyMotor = function(){

	var coreX = Math.seededRandom(2,numSpeeds);
	var coreY = Math.seededRandom(2,numSpeeds);
	
	var topY = 0;
	var leftX = 0;
	var rightX = 0;
	var bottomY = 0;
	
	if(Math.seededRandom(0,1) == 1)
		topY = Math.seededRandom(2,5);
	if(Math.seededRandom(0,1) == 1)
		leftX = Math.seededRandom(2,5);
	if(Math.seededRandom(0,1) == 1)
		rightX = Math.seededRandom(2,5);
	if(Math.seededRandom(0,1) == 1)
		bottomY = Math.seededRandom(2,5);
	
	if(topY == 0 && leftX == 0 && rightX == 0 && bottomY == 0){
		side = Math.seededRandom(1,4);
		if(side == 1)
			topY = Math.seededRandom(2,5);
		else if(side == 2)
			leftX = Math.seededRandom(2,5);
		else if(side == 3)
			rightX = Math.seededRandom(2,5);
		else
			bottomY = Math.seededRandom(2,5);
	}
	
		
	var size = Math.max(coreX + rightX + leftX, coreY + topY + bottomY);
	
	var enemyGrid =[];
	for(var i =0; i < size; i+= 1){
		enemyGrid.push(new Array(size));
	};
	
	if(topY > 0)//grid, moveX, moveY,motorX,motorY,minLength,maxLength,thickness
		designMotor(enemyGrid, 0, -1,-1,topY - 1,leftX,size - rightX + 1,topY);
	if(bottomY > 0)
		designMotor(enemyGrid, 0, 1,-1,size - bottomY,leftX,size - rightX + 1,bottomY);	
	if(leftX > 0)
		designMotor(enemyGrid, -1, 0,leftX - 1,-1,topY, size - bottomY + 1,leftX);
	if(rightX > 0)
		designMotor(enemyGrid, 1, 0,size - rightX,-1,topY, size - bottomY + 1,rightX);
		
	//add center
	gridSquares = []
	var i =0;
	for(var x =0; x < coreX; x += 1){
		for(var y =0; y < coreY; y += 1){
			enemyGrid[x + leftX][y + topY] = new TempBlock("wall",x + leftX,y + topY);
			gridSquares[i] = [x + leftX,y + topY]
			i += 1;
		}
	}
	
	var ind = Math.seededRandom(0,gridSquares.length - 1);
	var square = gridSquares.splice(ind,1)[0];
	
	var heartX = square[0];
	var heartY = square[1];
	
	var central = (heartX >= 2 && coreX + rightX - heartX >= 2 && heartY >= 2 && coreY + bottomY - heartY >= 2);
	if(central)
		central = isWall(enemyGrid,heartX - 1,heartY) && isWall(enemyGrid,heartX - 1,heartY - 1) && isWall(enemyGrid,heartX,heartY - 1)
		&& isWall(enemyGrid,heartX + 1,heartY + 1) && isWall(enemyGrid,heartX + 1,heartY)  && isWall(enemyGrid,heartX,heartY + 1) && isWall(enemyGrid,heartX - 1,heartY + 1) && isWall(enemyGrid,heartX + 1,heartY - 1);
	
	//make multiple attempts to put heart in centre to make chance of central heart more likely
	for(var t = 0; t < 10 && !central && gridSquares.length > 0; t += 1){
		square = []
		if(gridSquares.length == 1)
			square = gridSquares[0];
		else{
			ind = Math.seededRandom(0,gridSquares.length - 1);
			square = gridSquares.splice(ind,1)[0];
		}
		heartX = square[0];
		heartY = square[1];
		
		heartX = Math.seededRandom(leftX,coreX + leftX);
		heartY = Math.seededRandom(topY,coreY + topY);
		central = (heartX >= 2 && coreX + rightX - heartX >= 2 && heartY >= 2 && coreY + bottomY - heartY >= 2)
	}
	
	enemyGrid[heartX][heartY] = new TempBlock("heart",heartX,heartY);
	
	var size = Math.seededRandom(minEnemyGrid, maxEnemyGrid);

	return enemyGrid;
}

//moveX, moveY = direction moved as spread outwards (thickness wise) across rows of arm
function designMotor(grid, moveX, moveY,motorX,motorY,minLength,maxLength,thickness){
	var pointX = 0;
	var pointY = 0;
	
	if(motorX == -1){
		if(Math.seededRandom()){
			pointX = 1;
			motorX = minLength;
		}
		else{
			motorX = maxLength - 1;
			pointX = -1;
		}
				
	}
	else if(motorY == -1){
		if(Math.seededRandom()){
			motorY = minLength;
			pointY = 1;
		}
		else{
			motorY = maxLength - 1;
			pointY = -1;
		}	
	}
	var x = motorX;
	var y = motorY;
	grid[x][y] = new TempBlock("motor",x,y);
	
	var length = 0;
	var numRows = Math.min(3,thickness - 1)
	
	
	var maxL = maxLength - minLength - 1;
	var endLast = 0;
	var startLast = 0;
	var oldSt = 0;
	var oldEnd = 0;
	var st = 0;
	var end = 0;
	for(var r = 0; r < numRows; r += 1){
		x += moveX;//move outwards (thickness wise)
		y += moveY;
		var length = Math.seededRandom(1,maxL);
		oldSt = 0;
		oldEnd = length;
		if(r > 0){
			st = Math.seededRandom(0,length - 1);
			end = Math.seededRandom(st + 1, length);
			if(st < oldSt && end < oldEnd)
				end = oldEnd;
			else if(st > oldSt && end > oldEnd)
				st = oldSt;
			oldSt = st;
			oldEnd = end;
			
		}
		
		for(var i =0 ; i < length; i+= 1){
			grid[x][y] = new TempBlock("wall",x,y);
			x += Math.abs(pointX);
			y += Math.abs(pointY);
		}
		if(pointX == 1){
			x = st + minLength;
		}
		else if(pointX == -1){
			x = minLength + end;
		}
		else if(pointY == 1){
			y = st + minLength;
		}
		else if(pointY == -1){
			y = minLength + end;
		}
	}
	
}

function isWall(grid,x,y){
	if(x < 0 || x >= grid[0].length || y < 0 || y >= grid[0].length)
		return 0;
	if(grid[x] == undefined || grid[x] == null || grid[x][y] == undefined || grid[x][y] == null)
		return 0;
	if(grid[x][y].type == "wall")
		return 1;
	else 
		return 0;
	
	
}


